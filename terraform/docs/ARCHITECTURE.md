# Flora Terraform Architecture - Deep Dive

## üéØ Core Concepts

### Terraform vs AWS Console

| Aspect | AWS Console (Manual) | Terraform (IaC) |
|--------|---------------------|-----------------|
| **Creation** | Click through UI | Write code |
| **Reproducible** | ‚ùå No | ‚úÖ Yes |
| **Version Control** | ‚ùå No | ‚úÖ Yes (git) |
| **Team Collaboration** | ‚ùå Hard | ‚úÖ Easy |
| **Track Changes** | ‚ùå Manual | ‚úÖ Automatic (state) |
| **Automation** | ‚ùå No | ‚úÖ Yes |

### How Terraform Works

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Terraform Workflow                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. You Write Code (.tf files)
   ‚Üì
2. Terraform Init (downloads providers)
   ‚Üì
3. Terraform Plan (preview changes)
   ‚Üì
4. Terraform Apply
   ‚îÇ
   ‚îú‚îÄ> Reads your .tf files
   ‚îú‚îÄ> Reads current state (terraform.tfstate)
   ‚îú‚îÄ> Calculates diff: "What needs to change?"
   ‚îú‚îÄ> Calls AWS APIs to create/update/delete resources
   ‚îî‚îÄ> Updates state file
   ‚Üì
5. Resources Created in AWS
   ‚Üì
6. Terraform Outputs (URLs, endpoints, etc.)
```

## üìÅ File Architecture & Data Flow

### Main Terraform Files

```
terraform/
‚îú‚îÄ‚îÄ main.tf              # üß† Brain: Orchestrates everything
‚îú‚îÄ‚îÄ variables.tf         # üìù Schema: Defines what inputs needed
‚îú‚îÄ‚îÄ terraform.tfvars     # üîê Values: Your actual secrets/config
‚îú‚îÄ‚îÄ outputs.tf           # üì§ Results: What to display after creation
‚îî‚îÄ‚îÄ .terraform.tfstate   # üíæ State: Current infrastructure snapshot
```

### Module Architecture

```
modules/
‚îú‚îÄ‚îÄ rds/                  # Database component
‚îÇ   ‚îú‚îÄ‚îÄ main.tf          # Creates: RDS instance, subnet group, security group
‚îÇ   ‚îú‚îÄ‚îÄ variables.tf     # Needs: VPC ID, password, subnet IDs
‚îÇ   ‚îî‚îÄ‚îÄ outputs.tf       # Provides: DB endpoint, connection string
‚îÇ
‚îú‚îÄ‚îÄ elastic_beanstalk/   # Backend API component
‚îÇ   ‚îú‚îÄ‚îÄ main.tf          # Creates: EB app, environment, ALB, IAM roles
‚îÇ   ‚îú‚îÄ‚îÄ variables.tf     # Needs: VPC ID, subnets, env vars
‚îÇ   ‚îî‚îÄ‚îÄ outputs.tf       # Provides: API URL, security group ID
‚îÇ
‚îî‚îÄ‚îÄ s3_cloudfront/       # Frontend CDN component
    ‚îú‚îÄ‚îÄ main.tf          # Creates: S3 bucket, CloudFront distribution
    ‚îú‚îÄ‚îÄ variables.tf     # Needs: Project name, backend URL
    ‚îî‚îÄ‚îÄ outputs.tf       # Provides: CloudFront URL, bucket name
```

## üîÑ Complete Data Flow Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       CONFIGURATION LAYER                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

terraform.tfvars (You fill this)
‚îú‚îÄ database_password = "secret123"
‚îú‚îÄ auth0_client_secret = "xyz..."
‚îî‚îÄ stripe_secret_key = "sk_..."
         ‚îÇ
         ‚ñº
variables.tf (Schema validation)
‚îú‚îÄ Validates types
‚îú‚îÄ Marks sensitive vars
‚îî‚îÄ Provides defaults
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     ORCHESTRATION LAYER                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

main.tf
‚îú‚îÄ Creates VPC, subnets, routing
‚îÇ
‚îú‚îÄ Calls Module: RDS
‚îÇ  ‚îî‚îÄ Passes: vpc_id, subnets, password
‚îÇ      ‚îÇ
‚îÇ      ‚ñº
‚îÇ  modules/rds/main.tf creates:
‚îÇ      ‚îú‚îÄ aws_db_subnet_group
‚îÇ      ‚îú‚îÄ aws_security_group (allow port 5432 from EB)
‚îÇ      ‚îî‚îÄ aws_db_instance (PostgreSQL)
‚îÇ          ‚îÇ
‚îÇ          ‚îî‚îÄ Outputs: connection_string
‚îÇ
‚îú‚îÄ Calls Module: Elastic Beanstalk
‚îÇ  ‚îî‚îÄ Passes: vpc_id, subnets, env_vars
‚îÇ      ‚îú‚îÄ env_vars.DATABASE_URL = module.rds.connection_string ‚óÑ‚îÄ‚îÄ‚îê
‚îÇ      ‚îÇ                                                            ‚îÇ
‚îÇ      ‚ñº                                                            ‚îÇ
‚îÇ  modules/elastic_beanstalk/main.tf creates:                      ‚îÇ
‚îÇ      ‚îú‚îÄ aws_elastic_beanstalk_application                        ‚îÇ
‚îÇ      ‚îú‚îÄ aws_elastic_beanstalk_environment                        ‚îÇ
‚îÇ      ‚îÇ   ‚îî‚îÄ Environment Variables:                               ‚îÇ
‚îÇ      ‚îÇ       ‚îú‚îÄ DATABASE_URL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ      ‚îÇ       ‚îú‚îÄ AUTH0_DOMAIN
‚îÇ      ‚îÇ       ‚îî‚îÄ STRIPE_SECRET_KEY
‚îÇ      ‚îú‚îÄ aws_security_group (allow HTTP/HTTPS)
‚îÇ      ‚îú‚îÄ IAM roles & policies
‚îÇ      ‚îî‚îÄ Application Load Balancer
‚îÇ          ‚îÇ
‚îÇ          ‚îî‚îÄ Outputs: application_url, security_group_id
‚îÇ
‚îî‚îÄ Calls Module: S3 + CloudFront
   ‚îî‚îÄ Passes: backend_url = module.elastic_beanstalk.application_url
       ‚îÇ
       ‚ñº
   modules/s3_cloudfront/main.tf creates:
       ‚îú‚îÄ aws_s3_bucket
       ‚îú‚îÄ aws_s3_bucket_policy (allow CloudFront)
       ‚îú‚îÄ aws_cloudfront_distribution
       ‚îÇ   ‚îî‚îÄ Origin: S3 bucket
       ‚îî‚îÄ Outputs: cloudfront_url, bucket_name
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        OUTPUT LAYER                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

outputs.tf aggregates:
‚îú‚îÄ frontend_url = module.s3_cloudfront.cloudfront_url
‚îú‚îÄ backend_url = module.elastic_beanstalk.application_url
‚îî‚îÄ database_endpoint = module.rds.db_endpoint (sensitive)
```

## üé¨ Step-by-Step Execution

### When you run `terraform apply`:

```
PHASE 1: INITIALIZATION
‚Üí Read all .tf files
‚Üí Load terraform.tfvars
‚Üí Validate syntax

PHASE 2: DEPENDENCY GRAPH
Terraform builds a graph:

  VPC
   ‚îú‚îÄ> Subnets
   ‚îÇ    ‚îú‚îÄ> RDS (needs subnets)
   ‚îÇ    ‚îî‚îÄ> EB (needs subnets)
   ‚îÇ         ‚îî‚îÄ> Needs RDS output first!
   ‚îî‚îÄ> Internet Gateway
        ‚îî‚îÄ> Route Table

PHASE 3: PARALLEL EXECUTION
‚Üí Creates independent resources in parallel
‚Üí Waits for dependencies

Example Timeline:
[0:00] VPC created
[0:30] Subnets + IGW created (parallel)
[1:00] RDS starts creating
[5:00] RDS ready ‚Üí EB starts creating
[8:00] EB ready ‚Üí S3 + CloudFront start
[10:00] All complete!

PHASE 4: STATE MANAGEMENT
‚Üí Saves to terraform.tfstate:
  {
    "vpc_id": "vpc-abc123",
    "rds_endpoint": "flora-db.xxx.rds.amazonaws.com",
    ...
  }
```

## üîó Module Communication

### Example: How RDS password reaches the database

```
1. You set in terraform.tfvars:
   database_password = "SecurePass123!"

2. variables.tf defines it:
   variable "database_password" {
     type = string
     sensitive = true
   }

3. main.tf passes to RDS module:
   module "rds" {
     database_password = var.database_password  # From tfvars
   }

4. modules/rds/variables.tf receives it:
   variable "database_password" {
     type = string
   }

5. modules/rds/main.tf uses it:
   resource "aws_db_instance" "postgres" {
     password = var.database_password
   }

6. modules/rds/outputs.tf includes it in connection string:
   output "connection_string" {
     value = "postgresql://user:${var.database_password}@endpoint/db"
     sensitive = true
   }

7. main.tf uses that output for EB:
   module "elastic_beanstalk" {
     env_vars = {
       DATABASE_URL = module.rds.connection_string
     }
   }

8. EB module sets it as environment variable:
   setting {
     namespace = "aws:elasticbeanstalk:application:environment"
     name      = "DATABASE_URL"
     value     = var.env_vars["DATABASE_URL"]
   }

9. Your backend Docker container reads it:
   process.env.DATABASE_URL
```

## üìä State File (`terraform.tfstate`)

### What is it?

```json
{
  "version": 4,
  "terraform_version": "1.5.0",
  "resources": [
    {
      "type": "aws_vpc",
      "name": "main",
      "instances": [
        {
          "attributes": {
            "id": "vpc-0abc123def456",
            "cidr_block": "10.0.0.0/16"
          }
        }
      ]
    },
    {
      "type": "aws_db_instance",
      "name": "postgres",
      "instances": [
        {
          "attributes": {
            "id": "flora-db",
            "endpoint": "flora-db.xyz.ap-southeast-2.rds.amazonaws.com:5432"
          }
        }
      ]
    }
  ]
}
```

### Why important?

1. **Tracks reality**: Terraform knows what exists in AWS
2. **Enables updates**: Compare current vs desired state
3. **Prevents conflicts**: Multiple team members don't create duplicates
4. **Allows destruction**: Terraform knows what to delete

### State Management Best Practices

```bash
# ‚ùå BAD: Local state file (lost if computer dies)
terraform apply  # Creates terraform.tfstate locally

# ‚úÖ GOOD: Remote state in S3 (team-shared, backed up)
# In main.tf:
terraform {
  backend "s3" {
    bucket = "flora-terraform-state"
    key    = "production/terraform.tfstate"
    region = "ap-southeast-2"
  }
}
```

## üèóÔ∏è Infrastructure Lifecycle

### Create

```bash
terraform init    # Setup
terraform plan    # Preview
terraform apply   # Create
```

### Update

```bash
# Change main.tf (e.g., increase RDS storage)
terraform plan    # Shows: will update aws_db_instance
terraform apply   # Updates only that resource
```

### Destroy

```bash
terraform destroy  # Deletes EVERYTHING
# Or destroy specific resource:
terraform destroy -target=module.rds
```

## üéì Key Concepts Summary

| Concept | What it is | Why it matters |
|---------|-----------|----------------|
| **Resource** | Single AWS thing (VPC, RDS, S3) | Building blocks |
| **Module** | Group of related resources | Reusable components |
| **Variable** | Input parameter | Customization |
| **Output** | Result/info to expose | Pass data, show URLs |
| **State** | Current infrastructure snapshot | Enables updates/deletes |
| **Provider** | AWS API connector | How Terraform talks to AWS |
| **Data Source** | Read existing AWS resource | Use existing infrastructure |

## üîç Debugging Tips

### See what Terraform will do:
```bash
terraform plan -out=tfplan
terraform show tfplan  # Detailed view
```

### See current state:
```bash
terraform show  # All resources
terraform state list  # List resources
terraform state show aws_vpc.main  # Show specific resource
```

### See outputs:
```bash
terraform output  # All outputs
terraform output backend_api_url  # Specific output
```

### Visualize dependency graph:
```bash
terraform graph | dot -Tpng > graph.png
```

This will create a visual diagram of how resources depend on each other!
